import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Country } from '../entities/country.entity';
import { Repository } from 'typeorm';
import * as fs from 'fs';
import * as path from 'path';
const csv = require('csv-parser');
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';
import { CountryCsvDto } from '../dto/country-csv.dto';

@Injectable()
export class CountrySeederService {
  constructor(
    @InjectRepository(Country)
    private readonly countryRepo: Repository<Country>,
  ) {}

  async seedFromCSV(): Promise<void> {
    const filePath = path.resolve(__dirname, '../../../src/country/seed/countries.csv');
    const rawRows: any[] = [];

    return new Promise((resolve, reject) => {
      fs.createReadStream(filePath)
        .pipe(csv())
        .on('data', (row) => {
          // Skip rows with missing required fields
          if (!row.name || !row.alpha2 || !row.code) {
            console.warn('⚠️ Skipping invalid row:', row);
            return;
          }
          rawRows.push(row);
        })
        .on('end', async () => {
          const dtos = plainToInstance(CountryCsvDto, rawRows, {
            excludeExtraneousValues: true,
          });

          const validEntities: Country[] = [];
          const errors: { row: number; issues: string[] }[] = [];

          for (let i = 0; i < dtos.length; i++) {
            const dto = dtos[i];
            const validationErrors = await validate(dto);

            if (validationErrors.length > 0) {
              errors.push({
                row: i + 1,
                issues: validationErrors.flatMap(err => Object.values(err.constraints || {})),
              });
              continue;
            }

            validEntities.push(this.countryRepo.create(dto));
          }

          if (validEntities.length > 0) {
            await this.countryRepo.save(validEntities);
            console.log(`✅ Seeded ${validEntities.length} countries`);
          }

          if (errors.length > 0) {
            console.warn(`⚠️ Validation errors in ${errors.length} rows:`);
            errors.forEach(err =>
              console.warn(`Row ${err.row}: ${err.issues.join('; ')}`)
            );
          }

          resolve();
        })
        .on('error', reject);
    });
  }
}
